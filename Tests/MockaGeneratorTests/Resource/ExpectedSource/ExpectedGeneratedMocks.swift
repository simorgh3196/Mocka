// MARK: - Mocks generated by Mocka
// Don't edit this file

import Mocka
@testable import Mocka

func test() {
    let mock = MockSimpleProtocol()

    stub(mock) { stub in
        when(stub.readWriteProperty.get)
                .thenReturn(10)
                .thenReturn(10)
                .thenReturn { 10 * 20 }
    }
}

class MockSimpleProtocol: SimpleProtocol, Mock {
    static let identifier: String = "SimpleProtocol"
    lazy var stub = Stubbing(mock: self)
    lazy var verification = Verificating(mock: self)

    var readWriteProperty: Int = 0
    var optionalProperty: Int? = 0
    func noReturn() {}
    func withParam(_ param: String, param2: String) -> Int { fatalError() }

    class Stubbing: Stub {

        let mock: MockSimpleProtocol

        init(mock: MockSimpleProtocol) {
            self.mock = mock
        }

        var readWriteProperty: StubProperty<MockSimpleProtocol, Int> {
            return StubProperty(mock: mock, identifier: "readWriteProperty")
        }

        var optionalProperty: StubProperty<MockSimpleProtocol, Int?> {
            return StubProperty(mock: mock, identifier: "optionalProperty")
        }

        func noReturn() -> StubFunction<MockSimpleProtocol, Void, Void> {
            return StubFunction(
                mock: mock,
                identifier: "noReturn()",
                input: ()
            )
        }

        func withParam<_String: Matchable>(_ param: _String, param2: _String) -> StubFunction<MockSimpleProtocol, (String, String), Int>
                where _String.MatchedType == String
        {
            return StubFunction(
                mock: mock,
                identifier: "withParam(_ param: String, param2: String) -> Int",
                input: (param, param2)
            )
        }
    }

    class Verifying: Verification {

        let mock: MockSimpleProtocol

        init(mock: MockSimpleProtocol) {
            self.mock = mock
        }
    }
}

class MockNormalProtocol: NormalProtocol, Mock {

    required init() {
        fatalError()
    }

    required init(labelA a: String, _ b: String) {
        fatalError()
    }

    var readOnlyProperty: String {
        get {
            fatalError()
        }
    }

    var readWriteProperty: Int {
        get {
            fatalError()
        }
        set {
            fatalError()
        }
    }

    var optionalProperty: Int? {
        get {
            fatalError()
        }
        set {
            fatalError()
        }
    }

    static var staticReadOnlyProperty: String {
        get {
            fatalError()
        }
    }

    static var staticReadWriteProperty: Int {
        get {
            fatalError()
        }
        set {
            fatalError()
        }
    }

    static var staticOptionalProperty: Int? {
        get {
            fatalError()
        }
        set {
            fatalError()
        }
    }

    func noReturn() {
        fatalError()
    }

    func withThrows() throws -> Int {
        fatalError()
    }

    func withNoReturnThrows() throws {
        fatalError()
    }

    func withParam(_ param: String) -> Int {
        fatalError()
    }

    func withClosure(_ closure: (String) -> Int) -> Int {
        fatalError()
    }

    func withParamAndClosure(param: String, closure:(String) -> Int) -> Int {
        fatalError()
    }

    func withEscapeClosure(closure: @escaping (String) -> Void) {
        fatalError()
    }

    func withOptionalClosure(closure: ((String) -> Void)?) {
        fatalError()
    }

    func withOptionalClosureAndReturn(closure: ((String) -> Void)?) -> Int {
        fatalError()
    }

    func withLabelAndUnderscore(labelA a: String, _ b: String) {
        fatalError()
    }

    func withNamedTuple(tuple: (a: String, b: String)) -> Int {
        fatalError()
    }

    func withImplicitlyUnwrappedOptional(i: Int!) -> String {
        fatalError()
    }

    static func staticNoReturn() {
        fatalError()
    }

    static func staticWithThrows() throws -> Int {
        fatalError()
    }

    static func staticWithNoReturnThrows() throws {
        fatalError()
    }

    static func staticWithParam(_ param: String) -> Int {
        fatalError()
    }

    static func staticWithClosure(_ closure: (String) -> Int) -> Int {
        fatalError()
    }

    static func staticWithParamAndClosure(param: String, closure:(String) -> Int) -> Int {
        fatalError()
    }

    static func staticWithEscapeClosure(closure: @escaping (String) -> Void) {
        fatalError()
    }

    static func staticWithOptionalClosure(closure: ((String) -> Void)?) {
        fatalError()
    }

    static func staticWithOptionalClosureAndReturn(closure: ((String) -> Void)?) -> Int {
        fatalError()
    }

    static func staticWithLabelAndUnderscore(labelA a: String, _ b: String) {
        fatalError()
    }

    static func staticWithNamedTuple(tuple: (a: String, b: String)) -> Int {
        fatalError()
    }

    static func staticWithImplicitlyUnwrappedOptional(i: Int!) -> String {
        fatalError()
    }
}
